Transcript for video at path D:\Downloads\IntelliJ-setup.mp4:
 Hello, this tutorial video will show you how to use the IntelliJ idea integrated development environment for Java projects. So what does this tutorial cover? We will show you how to create a new project in IntelliJ and how to open existing ones. We will also show you how to set up the Java JDK parts in IntelliJ in case it is not able to find out where you have installed Java on your computer. How to add new and existing classes within an existing project? How to work with the JUnit testing framework in IntelliJ? And finally, how to use a code style within IntelliJ? So let us start up IntelliJ idea and see how to start a new Java project. So the first time you open IntelliJ idea, this is the welcome screen that you see. And consequently, when you open up IntelliJ idea, you may see a list of recently used projects here. So there are four options. The first one is used to create a new project, which we really use. The second is if you want to import an existing IntelliJ project that you perhaps downloaded from somewhere. The third is to open a project that already exists that you have created. And the fourth option is relevant only when you have an IntelliJ project set up on a version control system such as Git. So for now, let's start with the create new project. So you come to the first screen here and you notice that the project SDK says none. Now this may happen the first time you install IntelliJ. What it's telling you is that it cannot find the Java development toolkit installed anywhere on your machine. Now if you don't have it, you would need to install the Java JDK. And so go to the Oracle website and download the Java development toolkit. The current version is Java 8. So download that toolkit and install it in a specific place on your computer. It doesn't matter where you store it. So for example, mine is stored in C program files Java. And then I have two of them installed Java 1.8 and Java 1.7. So coming back to IntelliJ, if you see this or if you don't see the JDK that you're looking for, click on new and then set up JDK. And then navigate to the folder where you have installed this. So in my case, it is C program files Java and there's the JDK 1.8. Click OK. And you see that that option now comes up. If you wish to add multiple JDK, so let me add the Java 7 one also. So in Java 7, here's this 1.7. So now the drop down menu shows both 1.8 and 1.7. Now you need to do this only once in IntelliJ once you have done it. It will work for any new projects that you create from this point on. So I'm going to select Java 8 and not touch anything else on this screen. Go to next. All right. So now we come to the name and the location of the project. So my advice is to create a folder somewhere on your computer that will store all the Java projects that you will need for this course. So in my case, let me make a new folder projects. And so in here, I wish to have all my IntelliJ projects with one folder each. So let me click on this button and point it to the folder that I just created. The documents, teaching, CS 3500 and projects. Right. And now let me call the project Hello World. Now sometimes it will not add the folder here. I want it to create a new folder called Hello World. So sometimes it will do it by default. If it doesn't either type it there or you can create a new module which has the same name. And so that will create your Hello World project. So with the screen that looks like this, now press finish. It may give you a warning saying the folder doesn't exist. So it will be created. And now it will have created a folder with that project Hello World. So if you click on this, it will now take you to the folder over here. So there are several views that you can have. You can have a project level view. You can have a package level view and so on and so forth. So what do you see in this folder? There is a hidden folder called .idea and then there is a folder called source and this file that actually stores all the IntelliJ specific settings. So that's your project file. If you look at what it did inside the project folder, created a new folder called Hello World, going inside it you see the source folder, the IML file and the .idea. So all your Java files, the source code that you write, should be placed under the source folder right here. So at this point, you have a new project created. We don't have any classes or files defined in it. So after we've created a new IntelliJ project, let's now see how to add new classes or existing classes to your project. So this is the Hello World project that we created. To create a new class, you can just right click on the source folder, say new, and the name of the class. So you can use this to either create a new class or a new interface. So let me create the publication interface. When I press OK, it has now created a publication .java and it has put it inside the source folder. You can verify that by going into your source folder and seeing that it is publication. OK. So this is the easiest way you can create a new class or a new interface from within IntelliJ. Now what if I wanted this interface to live in a different package? So I would type the package name at the top of the java file. Now immediately you see that IntelliJ flags this as an error. IntelliJ has a hint giving mechanism which are these little yellow and red bulbs that you see popping up. So if you just click on that, a red bulb pops in. So if you hover around it, the error message that you get is package name CS3500.homework1. publication does not correspond to the file path. And the reason for this is that because java enforces your packages to follow that folder structure, it would like within the source folder to have a folder called CS3500 inside that folder called homework01, inside that folder called publication, and inside the publication folder you should place this java file. So either you can do so manually by creating new folders here or you can do it using IntelliJ. So if you click on that, you will see this red bulb icon come up. So this is what gives you suggestions. Now these suggestions are helpful but I strongly recommend you read them and you understand what they mean before selecting the correct one. So as often selecting the wrong suggestion is going to bring even more trouble for you. So in this case, I wanted to move to package CS3500 homework01 publication. So when I select that, you see on the left hand side here that it shows that that publication interface is now inside this. Now this is a shorthand. It's showing you CS3500.homework01.publication but if you look at your file system within the source folder, it has now created CS3500 homework01 publication and right there is the publication interface. So in this way, you can create a new class or a new interface. If you want to create another new class to live in the same package, this time instead of right clicking on source to create a new class, you can right click directly on the package and now the class that you create will automatically be put in that package. So what if you have some starter code to begin with and you wish to now add that code to this project. So let's take an example of that. So here I have four classes that are already done. So I'm going to copy them and to put them in this project, all you have to do is go to the project folder, so hello world, source and then just paste them over here. If they were supposed to be in separate packages, we can take care of that later but you can start by just pasting them in the source folder and then you see that immediately they pop up over here and so you see that now you get the same error that you had before. As I said, you can avoid this by first creating the appropriate folders and then copying those files correctly but we can follow along and let IntelliJ put them at the correct place. Move and then the interface. Let move it there and now because we've already created a file by that exact same name, it says it can't do it. So in that case, you have to manually copy it, CS, publication right there and then replace the file. And now you see that in your folder, all these files live in the CS 3500.homberg0, 1.publication in package. So this folder right here is called the sources root. It is automatically marked as that when you create an IntelliJ project and you can see that if you go to, if you right click on that folder and say mark directory as, it's already marked as the sources root because it only gives you an option to unmark it. So don't do it but what the sources root means is that when you ask IntelliJ to do anything with these files, that is the folder in which it expects all your source code, all your Java files to be in. And so any package structure that you have for those files should be inside this source folder. So that's what it means by marking it as sources root right. So now we have seen how to add a new class within an existing IntelliJ project or alternatively how to create a how to add existing classes or existing files to an IntelliJ project. Now that we have created a project and IntelliJ and added some classes and interfaces to it, let us now see how to test them within IntelliJ. So we are going to use the JUnit Testing Framework which is a Java-based unit testing framework. Now JUnit is not packaged with the Java development kit. It's a separate download. However, if you're using IntelliJ, IntelliJ comes with JUnit inside it. What that means is you don't need to install it or download it separately. It's already there. So let's see how to work with JUnit in IntelliJ. So here's the project that we created and the classes and interfaces that we added right there. Now I recommend that you organize your test files separate from your source files. And to do that, I'm going to create a new folder inside this project. So right click on the project and say new directory. Let me call it test. And so it creates a test folder. Now similar to how it's going to look for all your source code inside the source directory here because that directory has been marked as the sources root. Similarly, I wanted to look for all the tests inside the test directory instead of the source one. So I would have to mark this as the test sources root. So right click on this folder, select mark directory as. And now you see an option called test sources root. So select that. Now the evidence that it worked is that it would change color like that but that's not a very obvious hint. So if you ever want to know if the folders have been marked correctly, there are two ways to do it. Kind of an indirect way is to try doing it again. And now it will see that it does not give you that option. It gives you the option to unmarket which means it's currently marked as the test sources root. So that's one way to find out. The other way to find out is to go to files, project structure. And right here go to the module stab and you see here that that's your sources, your source folders. So it's marked as the source sources root. And then the test source folders, it's marked as the test. So so long as you see those two here, it means you've set everything up correctly. So let's exit this. So now how to write a j unit test? Let's say we wish to write a j unit test class to test the book class right here. The easiest way to do that is to click on the name of the class and then the yellow icon, bulb icon comes up. And then you have an option here saying create test. So select that. And now it will show you different testing frameworks. Now I've used j unit before which is why it's showing me that as the default but sometimes it's going to show you gruby j unit. So look out for that. We do not need that. What we need is the j unit for. This is the name of the class that it's going to create. So I'm going to keep it that way. Unless you know what these are, don't select any of them. It's a good idea to put your test in the default package rather than the package of the class that you're testing. This also allows you to test whether you have set the visibility of all your methods, whether you've made them public, protected, private or default package access appropriately. So what I'm going to do is I'm going to delete the destination package. So now it's going to create it in the default package. And then when I press OK, you see that right here, right under the test folder, it has created book test or Java. So now you see here that it does not seem to recognize what j unit is. This is because although j unit is part of IntelliJ, this project has not been set up to use j unit. So that's why you see this error. So as before, let's click on that error. And then one of the hints is add j unit 4 to class path. So select that. Now, it gives you two options. If you have downloaded j units separately, then you can use those. Or you can simply use j unit 4 from IntelliJ IDEA distribution. So let's just do that. Now press OK. And now the error goes away. And so now I have set up the test class for one of the classes that I've written. So at this point, let me try writing a test. So as we all know, every unit test inside this class has to begin with the annotation at the right test. So that's a test one right there. And I'm just going to write a bogus test for now. Int a equals 2, int b equals 3. And then I'm simply going to say assert that a is not equal to b. So it has nothing to do with the book class right now. You would replace this with a more meaningful test. But just for the purposes of this demonstration, I'm creating a fictitious test. Let me create another one. One that I know will fail just so that we can see what happens when the test fails. So once again, I'm going to say int 2, int b is 3. And this time, I'm going to assert that the test will fail. So a is not equal to b. So I expect this test based fail. Let me also add a helpful message. So in case the assert fails, that's the message that I expect to see. And I know this test case is going to fail because I wrote it that way. So now I have two test cases over here. Now, how do you run this? Now, normally you would go to the top right and here you would have seen a run configuration for this test case. Since I haven't run it yet, you don't see anything. So the easiest way to create a run configuration is since you want to run the book test file, just right click on it and select run book test. And now it has started running it. And then you can see right here that it shows you the report. One of them failed. Two tests done. One failed. And then it showed you white failed. So it expected two, which is the first here. But it actually got three, which is the second input here. And you can click on to see the actual difference. If sometimes it's not obvious to you what the difference is. And here it opens up in new window and shows you exactly what it expected and exactly what it got. So this is the way you can see which test cases have passed and which ones have failed. So now let's go ahead and correct that test case. Now both of them should pass. That one. Both of them should pass. And so now, because I said run for the first time, it's created a new run configuration right here. A run configuration is simply, it creates a setting and it remembers which file to run, how to run it, and so on and so forth. So now to run this particular configuration, all you have to do is click on that red, know that green triangle icon right there. And now you see that all two tests have passed. So there's nothing more to show. So in this way, you can work with JUnit framework from within IntelliJ and write unit test for your Java code. Often we need to write code that adheres to some coding styles. For example, specific indentation, things that should start at a new line and so on and so forth. These code styles are available to us in style files. And so now let's see how to make IntelliJ work with such a style file. So this is the project that we created and let's look at the book class. The book class right now has some styling oddities. For example, this is not indented right here and then sometimes Java code should follow the convention that the opening brace comes on the same line as the definition of the class. So it has a few of these style errors. So let's see how to work with IntelliJ to remove these. So in order to work with a particular style file, you will often have access to the entire style file as XML, for example. IntelliJ uses XML based files for coding styles. So the first thing I've done is I've decided to use the Google style for Java code and for that I have downloaded the Google style file, which is an XML file that will work with IntelliJ. So here's that style file right here and so now I wish to use whatever style things are codified inside this file within my current IntelliJ project. So going back to my project, that is called the Google style. So currently IntelliJ does not know the existence of that file. And the way I know that is if you go to file and settings, go to editor and code style and here you will see schemes. So IntelliJ comes installed with a default which also becomes the project code style. You can change what the default is that way any projects that you create will use that style or you can specify a project specific style. So right now the only one that exists is the default that comes installed with IntelliJ. I do not have the Google style pop up over here. That's because IntelliJ doesn't know the existence of that file and so you have to tell IntelliJ that file exists by putting it in a specific place on your computer. Now this is called the IntelliJ idea configuration folder. When you install IntelliJ, part of its installation includes creating a folder somewhere on your computer where when you start up IntelliJ it's going to look for all its settings over there. So I need to place my file over there. Now where the configuration folder is depends on what platform you are using. So I have Windows so I know where it is but if you are not sure where it is on your machine if you are using Linux or Mac OS X, what you can do is Google for those configuration folders. So here I have simply done a Google search for IntelliJ configuration folders and you see that the first thing that comes up is IntelliJ idea project and IDE settings preference. So the page looks somewhat like this and then if you scroll down you will see IDE settings and so for the community edition which I am using the folder name that I am looking for is .IDIC and then the version which for me is 15. And so on Windows I am looking for user home which is C colon backslash, user backslash, user name and in it a folder called IntelliJ idea 15 or in my case for IntelliJ community edition I am looking for a folder with that name and then a folder called config. Now your file needs to be within a folder that called code styles inside that config file. So on my machine here is where the config folder is. As the page says it is under C colon users asesh.idic 15 backslash config. Now as you can see there is no folder here called code styles that may happen on your machine. You may not even have a folder called config so create a folder called config inside it create a folder called code styles and now here I am going to simply paste that file. So put it right there. Now if you go back to IntelliJ you will see that it has still not popped up. You can try exiting it and then selecting it again and you see that it still has it popped up. That is because IntelliJ will look for that folder only when it starts and so the cure for this is that you simply restart IntelliJ. So I have shut it down and now I will restart it and now as part of the start up process it is looking for what is inside that folder. So now that we are back in again let us go to files, settings, code styles and now when you drop down the scheme you will see that there is a new one called Google style. It is getting this name from that XML file so anyway I will select it and now once you have selected it now it has selected all the format things that that file specifies. So click on OK. If you still don't see the Google style file check that you have put that folder, check that you have put that file at the correct place and check that that file itself is a valid Google style file. The main reasons you will not see things over here. Press OK. So now this project has been set up to use that particular code style. Now as you are typing it will occasionally spring up and make those corrections but if you wanted to make the corrections explicitly then the way you can do that is just go to code right here and say reformat code or all F8 as the keyboard shortcut there says. So notice what happens when I select that. It is going to reformat all the code and look at what it did. According to that style file the opening brace should indeed be here. It is in that correctly you can see that again at work I will make the indentation bad. I will say code reformat code and it moves everything over. So if it is doing that it means it is correctly able to use the code style file that you have. And so in this way you can use existing code styles from within Intelligent. So in the last part let me briefly mention some problems that you may face when using Intelligent. Some of these problems have to do with an incorrect project structure. You might get bizarre errors like you are trying to run a test case and it says the test case is empty. The test suite is empty when it is obviously not or it may say this is not the correct package name but you can see that it has you have the correct folder structure within it. So if you see these and it is not obvious you may want to revisit and make sure that your project is structured properly. Hopefully your project may not be structured properly if you are trying to incorporate start or code in your project and you haven't done it at the correct place or you have downloaded an existing Intelligent project from somewhere and it has not been set up correctly on your machine. So let's go briefly once let's go over briefly once more about what the correct project structure should look like. So when you look at your project this way look at the left pane over here what you should see is the name of the project or the name of the modules strictly speaking and then you should see this dot idea folder you should see the source folder within it you should have all your source files in the appropriate package. If you are writing jnr test cases then they should be inside a test folder and rewind this video to see how you could have done that and then your test folders over here finally inside the project folder itself you should see the IML which is the IntelliJ project file for this. So verify that your project looks exactly like this you may or may not see this out folder that gets created only when you attempt to actually run something so this may not exist but very fine particular that all your source files are inside a folder called source and this is directly inside your project. If you have any other folders here and the source folder within it and all your sources within it that may be the reason it's giving you problems. Similarly test make sure it's it looks like this now also verify that your src or your source folder is marked as a sources root it will be by default but just in case look for this and similarly verify that your test folder is marked correctly as a test sources root and the way you do that again is it will not give you the option to market but to unmarket which means currently it is marked as the test sources root. You should also make sure that the project structure looks correct on your file system. So this is the folder projects where in which I plan to have all my IntelliJ projects one within every folder and so here's the folder for hello world. If you see any of your project folders outside here that's a hint that something is gone wrong. So inside this you should see the dot idea you should see the source you should see the test and you should see this IML file. The IML file should be in the same folder as the source and test again if it is at a different place chances are there's been some mistake in how you set up the project. If you do conclude that your project has been incorrectly set up the fastest way I recommend is to just create a new project somewhere else create it correctly and then copy over your existing source and test files to the appropriate place within that project folder. Once that project works correctly inside IntelliJ you can copy the entire project folder which in this case is this one right here and paste it at the appropriate place on your computer. This way is just much faster than trying to troubleshoot problems by staying in the existing project. IntelliJ projects have to be structured a particular way and so if you just let IntelliJ create the project and define all the structure then that's an easy way to make sure you don't make these mistakes.
Transcript for video at path D:\Downloads\testing.mp4:
 Hello and welcome to a video tutorial on testing. This tutorial will walk you through how to think about and write tests for a simple enough example. We will be using Java as our programming language and JUnit as our testing framework. So in this video we will see how to start thinking about tests given a Java specification and a Java class in question. We will consider it on both black box testing and white box testing in this video. Black box tests are those that we come up by just looking at the specification without looking at the actual implementation. White box tests also test for scenarios that are sensitive to a particular implementation of a specification. So here we have an interface that represents a fraction. This is the example that we will be working with in this video. So here is an interface that represents a fraction. This is the example that we will be working with in this video. This interface defines a method that returns the decimal value of this fraction, get us to return the numerator and denominator parts of this fraction. A method that adds another fraction to this one and produces the result as a third independent fraction. Note that the documentation states that this method does not change either fraction. It also has a method that returns us whether this fraction is negative or not. So true if it is negative, falls off if it is non-negative. And finally it has a method that allows us to compare two fraction objects. Now technically this method signature does not need to be here because the interface explicitly states that it extends the comparable interface. But I chose to put it there just for clarity. Next we have an implementation fraction impulse that claims it implements the fraction interface. Now without going ahead and implementing each one of its methods, right now is the best time to start thinking about and writing black box unit tests. This way we can be sure that the tests we are writing are not biased by our own implementation. And therefore we don't end up writing tests that we know our implementation is going to pass. However let's talk about how this implementation represents a fraction first. So it represents the numerator and denominator separately as integers and also the sign as a separate number. Looking back at the interface we note that none of the methods cause the calling object to mutate. As a result we have guarded against unintentional modification by making all of them final. Now in addition to the methods that are declared in the interface, this class also provides a single constructor that takes an enumerator and denominator and constructs a fraction object. The documentation says that this constructor throws an illegal argument exception if the denominator part is zero. The numerator on the other hand can be any number. We also choose to override the standard two string method in Java for this class. This allows us to return a string representation of the fraction that can be useful for printing the contents of this fraction and also in our case for testing the fraction. Since there is no spec as to exactly how the string is going to be formatted, we've decided that we will formatted simply as numerator slash denominator. Further if the fraction is negative then the negative sign appears right before the numerator. If the fraction on the other hand is zero then it simply returns is zero. As you can see I have hidden the implementations of all these methods because we are going to write this first. We have also decided to override the default equals method so that it is now consistent with the compare to method that we plan to write in this class. As a general rule if you override equals for a class you must also override hash code so that your class behaves correctly with hash table implementations such as a hash map or a hash set. And therefore we have also chosen to override the hash code method. So let's go ahead and create our jnit test class that will be used to test fractions. So we use jnit 4. It's a good idea to put your test in the default package rather than the package of the class that we are testing. This ensures that we also have all our access modifiers correctly. In other words the test can see this class exactly as any other user will be able to see this class whether they are from outside the package. So let's go ahead and write our first test. The first thing that we will test is whether the fraction gets created correctly. So in other words testing that constructor. So what are the different things that we have to test for? Let's look at the constructor. It states that it constructs a fraction object from the given numerator and denominator. The numerator of this fraction may be any number. The denominator of this fraction may be any non-zero number. And it throws and it goes back to the denominator. So it is our job to test each and every part of the specification. So we will start with the simple cases where the denominator is not zero. And then we can take care of testing whether this constructor does indeed throw an illegal argument exception if the denominator we passed to it is zero or not. So we can start with a very simple example. We start by creating a simple fraction. And then we have to test whether this object got created as we intended. We intended to test whether this object got created as we intended. We intended to test whether this object got created as we intended. We intended to create a fraction that has the numerator 2 and a denominator 3. And so there are several ways we can use to test this. One way is to test the value. Let's not do that for now because it returns the decimal value and we don't want to have precision issues to worry about just yet. Another way we can use is to use the getters, get numerator, get denominator and finally the size. A third way we can is we have a two string method that in one fell swoop can test everything for us. So that's the one we are going to use. Now it might seem like a bit of a chicken and egg that we are using the two string method to test whether our constructor works correctly when we don't know if our two string method itself is correct or not. So at some in some sense this is unavoidable. We choose a simple enough getter or simple enough two string method to test others. And if those methods themselves have errors then these tests will unearth those as well. So the objective of this test is to whether fractions are created correctly with the test. And what is the valid input? A non zero denominator. And so how will we know that a fraction object has been created? We will know when this fraction ends up looking like this when I call its two string method. So if this assert passes what does it mean? It would mean that the numerator of this fraction has been set to two, the denominator of this fraction has been set to three and that this fraction is not negative because there is no negative sign there. So let's see if this test passes and we see that it the test indeed passes. Now does this really mean that our constructor works? And the answer to that question is definitely no because this is checking one specific example whereas our fraction constructor can take in any numerator and any denominator. So how do we test for this? It's impractical to test every possible numerator and every possible denominator in this case but this situation arises very commonly in testing. So we resort to a sampling technique instead of trying out every possible input. We try a large enough sample of randomly selected inputs and we base our assumption that if all of these randomly selected samples cause our test to pass that means the probability that our constructor is correct is reasonably high. So how do we set out to create this large enough sample of tests? We can do that very easily using random numbers. So we create our random number generator and then we take 10,000 samples. That's the nice thing about creating an automated test that it's possible to very quickly test a large number of samples. So here we first create a random integer for the numerator. We create a random integer for the denominator. Now because this test is testing explicitly that the denominator is non-zero, if by some chance the denominator return to us is zero, we just throw away this trial and move on to the next trial. Since we are trying 10,000 trials, we should still get enough samples with a non-zero denominator. So we have the numerator and denominator. That's what we will pass to this constructor. And now we have to create the expected string so that we can put it right there. So the expected string can be created by simply saying num plus slash plus den. Now this might appear correctly but notice that our numerator and denominator can be negative. And so we don't want for example a negative number to show up after the slash. So what we do is we take the absolute values here. But noting that the fraction we are about to create can be negative. We have to account for adding the sign in front. So we start by saying that it is not negative. And then we say well if the numerator happens to be zero then it is negative. And if the denominator happens to be zero or happens to be less than zero, we flip this again. So let's make sure our logic is sound. If both numerator and denominator are positive then none of the if statements will go in. Therefore negative is false. If only the numerator is zero then the first if statement will go in make negative true. The second if statement will not because the denominator is still positive. If we have the numerator to be positive and denominator will be negative then again it will go into just the second if statement. And finally if we have both negative numerator and denominator it will flip that negative twice making it false again. And so finally if it is negative we simply add a negative sign in front of the expected. So let's review this test. We take 10,000 samples for each sample we randomly generate a numerator and denominator. We throw away the sample if the denominator happens to be zero. We then create a fraction object from that numerator and denominator. We created our expected string by choosing the absolute values of the numerator and denominator. Then we figure out what the sign of this fraction should be. And we change the expected string by prepending it with a negative sign if the fraction is negative. And finally we do an assert. So let's see if this test passes. And we see that it fails. So something as simple as the constructor we see that we have found out an error somewhere. So let's see what the problem is. So in this case it's not passing because the two string is returning us in negative in the denominator. How can that be? Let's look at the two string method. And so right here is the problem. It's using the straight up numerator and denominator. We just saw while writing the test that it shouldn't be doing that. So let's take in the absolute value here. So this might be one fix for it but think about it. So the fraction is going to be represented as a numerator as an integer, a denominator as an integer. And the sign as a separate integer, then there is no need for the numerator and denominator to be negative numbers. Which means yes we can take care of this in the two string method as we just typed. But really it should be taken care of in the constructor. So according to this representation we can represent a fraction as a non-negative numerator in non-negative denominator. And then the sign that can be positive or negative depending on whether the fraction was positive or negative. So actually we will not put in this fix in the two string because it seems like a bandaid. It should have been taken care of in the constructor itself. So assuming that it is taken care of the constructor, taken care of in the constructor, the rest of this two string method up your sound. So let's look at our constructor now. And here we see that we need to take the absolute value. Alright, let's see if now we pass all our tests. And it still fails. Let's see what's going on. So we see that the expected value is a negative fraction but the actual value is a positive fraction. That's interesting. Let's run this a couple more times. And again it fails. This time it expects this fraction to be positive and yet the actual fraction happens to be negative. Alright, so we have already said that our two string method seems okay which means the constructor is not doing its job properly. So at this point pause this video and see if you can spot the bug. Alright, so we notice immediately that the logic that the constructor uses is different from what we wrote in our test. And that's fine. This is in fact the advantage of writing our test without having seen this logic. Now if you look closely at which test it's failing, you will notice that both the numerator and the denominator happen to be really big numbers. Well if you now look at this logic, if both those numbers are really big what do you think is going to happen to the product? It might overflow and when it overflows the sign becomes incorrect. Now on the face of it this logic is not wrong because if the numerator and the denominator have different signs then their product will have a negative sign. But if both of them have the same sign then their product is going to be positive. So mathematically this logic is solved. What comes in our way though is overflow. Okay and so let's change this logic to be similar to what we already wrote in our test. So if the numerator is negative the sign will flip. It's giving us that error because the sign happens to be a final so we can't reassign to it. So our trick is going to be to compute the value inside a temporary variable and then once its value has been obtained or signed it to it. So our logic here is very similar to the logic that we wrote in our test. Let's see if that fixes the problem. And indeed it does a set of 1000 randomly chosen numerators and denominators work correctly. So the probability that our constructor works correctly with non-zero denominators is pretty high. So this is an example of what we call fuzz testing or random sample testing. It's very useful in cases where there can be an inordinate number of possibilities that you must test against and it's not really practical to try each one of these possibilities. So now let's test the remainder of that constructor that is passing a zero for a denominator actually throws an exception. So we'll start by testing a specific example. We'll create a fraction that has a zero denominator. Now this test should pass if line 49 throws an exception and this test should fail if line 49 does not throw an exception. So the quickest way to do that in j unit is to say that this test expects an illegal argument exception to be thrown. So what this means is when this test is run the first instance that C is of an illegal argument exception being thrown it will abort the test and declare it a success. If it gets to the end of the test without seeing this exception even once then the test will fail. So let's run this test and we see that it passes. So once again we can try a lot of different combinations of numerators with a zero denominator. So let me replicate the 10,000 trials that we had with a random number generator. The denominator will always be negative and we have. So just 10,000 random numerators all with a zero denominator. Now running this test will pass but it's not necessarily doing what we think it is because remember what I said when you put this clause in there the test will abort and pass the first time it sees an illegal argument exception. In other words it will never go to the second trial and so even though this has a for loop that attempts to go 10,000 times the test is only going to be executed once. So if you are going to try a whole lot of inputs such that all of them should throw an exception then this is not the way to do it. So we go back to first principles and use a try catch. So in effect we must simulate the same behavior. The test should pass if each and every one of these throws an illegal argument exception which means the test should fail if even one of them does not throw an illegal argument exception. Now how do you make a test pass? You make it pass by somehow making it go all the way to the end and then by default it will pass. So if that statement if called the constructor actually throws an exception I wanted to continue going to the next trial. So this will ensure that it will go on to the second trial after it sees an exception. Running this test make sure that it passes but this is not complete because notice that this test is going to pass no matter what if it does not throw an exception even then it will go on to the next trial because it was simply not go to the cat statement. So we need to fail if the call to the constructor actually does not throw an exception and we can do that by issuing a fail statement here. Fraction constructor should have thrown an exception but didn't. So now let's let's review what's going to happen if at that line an exception is thrown it will skip the rest of the try block go straight to the catch block that is the exception that is thrown so it will catch it and in response it will simply say continue which will make it go to the next iteration of this follow as a tool. If that statement does not throw an exception then it will continue on to the next statement inside that try block which will fail this test right. So running this test now this is complete because it passes only when it should and we can see that the test now passes. Okay so after having tested the constructor using the two string method let's move on and test the other methods the other methods here are the next ones are get value get numerator get denominator and is negative all of these are in some sense get our methods they either directly get the attributes or the result of those attributes and so testing them should be pretty simple. What we will do is similar to how we constructed a large number of fractions we will do so again but this time we will test individual getters. So we start with a random number generator we create two integers numerator and denominator for now we will again throw away the zero denominator cases and now instead of having an expected string. We will test whether this has the correct numerator. This has the correct denominator and whether it has the correct sign. So this Boolean negative is going to be true if the fraction is actually negative and that's exactly what this should be returning. So let's run this test. The only thing that remains is testing that get value with it. Now unlike the other getters that we have seen the get value actually returns a double and so we need to check whether that is going to be what f dot get value returns. Now you see that this assert equals is crossed over because it is deprecated and this has to do with the fact that we are trying to check whether to floating point decimal numbers are equal to each other. This equality check is fraught with precision issues for example imagine what would happen if the numerator were 10 and the denominator were 3. The answer would be 3.33333 and so on and so forth and this assert equals is trying to check for exact equality. And so if one of the actual value happens to return 3.33333 4 and the calculated value in the expected part happens to be 3.33333 this assert is going to fail. And of course it should pass because well the two fractions are really equal to each other which is got defeated by precision. The way to get out of this in jUnit is to compare whether the two values are close enough to each other and we define close enough as being some sort of a delta or threshold. This is handy not only for jUnit but when you are trying to in general compare two floating point numbers. Instead of checking whether one is really equal to the other what we do is take their absolute difference and if that difference happens to be less than a certain threshold we deem them as equal to each other. And so we will just do that in jUnit form. So we will use a version of assert equals that has been tailor made for this purpose. The delta which is the third argument being 0.001 in effect says that if the two numbers the expected value and the actual value are within 3 decimal places of each other then this test should pass. And so you can see that it passes and there we have it. Now checking the 0 denominator case or the 0 numerator case is also hopefully taken care of in here. Remember that the is negative is supposed to return a true only if the number is negative. So for positive and for 0 it is supposed to return false. So because we have 10,000 different random samples we can assume that some of them gave us a numerator of 0 but it is not guaranteed. And so in order to do this properly we can have a case at the very end with the numerator being 0 and the denominator being something else. Think you will have, and so when you have that we assert that the numerator of this is actually 0. The denominator is what I passed it. Strictly speaking the spec does not say what the denominator will be when the numerator is 0. So we assume that it just as in all cases the denominator is whatever I passed to it. And thirdly the value of this is also 0. And so it passes. So let us move on and test the next method which is going to be add. So let us read the specification again. Add this fraction to another one and return the result this method does not change either fraction. Now how do we test whether the add method works correctly? We could create two fractions use that method to create a fraction that is the sum of these two fractions. But then how do we verify whether the result correct? So one way to do that is to explicitly use those getters numerator and denominator. This method although correct mathematically has a slight problem. The problem is that this method does not say one way or the other whether the fraction that it returns is reduced. In other words does it return 2 over 4 or will it return 1 over 2? And so trying to compare the numerator and the denominator explicitly may not always give us the right answer. For that reason you are trying to use the two string method is also not going to give us the useful answer. And so we rely on the answer correct by comparing its decimal point value with whatever we expect. So in other words we are going to test the add method using the get value getter instead of checking for the numerator and denominator because the interface does not say one way or the other about the form of the fraction that is returned by this method. So testing the add method will involve testing whether the answer is correct and we shouldn't forget also testing this part. This method does not change either fraction. So let's start that. We'll start with a simple example. We create two fractions. Let's say 2 over 3 and 3 over 4 and h will be f dot h g. Now 2 over 3 plus 3 over 4 is going to be 8 plus 9 which is 17 over 12. And so we want to assert that that is going to be the value of h. And once again we will use a delta of 0.001. Let's make sure this test runs and passes correctly. So as with the beginning of other tests this is just checking one specific pair of fractions. And so we need to make sure that add works for all possible pairs of fractions. So once again we resort to our random sampling. So I'm going to do 10,000 trials again. And this time I have to generate two fractions. So four numbers in general. Four numbers for every case. And fractions with zero denominators don't make any sense for this test case because if the fraction isn't valid trying to add it to something else is not valid either. And so I will weed out those cases. If d1 is 0 or d2 is 0 just throw away the trial. Another way to do this is use loops to generate the denominators and keep generating until you get a non-zero number. So we could have done that too. That method will guarantee us that we get exactly 10,000 trials. So n2 and d2. We add the two together. Now the value is going to be n1 times d2 plus d1 times n2 divided by d1 times d2. And therefore the expected value is going to be this. So let's look at our entire test in one go. For 10,000 trials we generate four numbers. Create two fractions out of them. Call the add method to get the sum. The expected value of the addition we use actual arithmetic. And then we check that the value of h which is returned by the add method is indeed matching our expected value. So let us run this test and see what happens. And it fails. Let's see the expected value is 1 is negative 1. And the actual value happens to be negative 1.4253. That doesn't help very much. Let's run another one. And again we see that the expected value is going to be 3.0. So let's make sure our test is right. And it is not because all the numbers involved are integers. This is doing integer division. So all I do is type cust one of them to double. And that will make all the calculations in double precision. And still it fails. And this time the error is a little different because the expected value is 2.16. And the actual value happens to be negative 0.209. Let's check again. Negative 1.1 and 0.87. Let's make sure our math is correct. N1 times D2 plus N1 times N2 divided by D1 times D2. So this happens to be correct. Now let's look at our add method. So it has two of them. This N1 and D1 are the denominator numerator, denominator numerator. And then we add back the N that is in there. The other one that is in there. Then we end up doing N1 times D2 plus N2 times D1 divided by D1 times D2. So it looks correct. Let's dig down deeper by actually printing what our fractions are. And then we can use D2 string. Spectre value. And that happens to be the actual value. So this time we are going to see when the test fails what were the two fractions that were created. We can actually do one better and we can say F dot 2 string plus G dot 2 string should be H dot 2 string. So now when it fails it gives us more information about why it is failing. What are the numbers it is dealing with? So when it has failed it says. So much like the case for the construction let's run it one more time. Kind of see it again. The numbers that it's getting are pretty big. So let's see if similar to the constructor we run into any overflow issues. And we see that we do. We are multiplying two numbers that happen to be very big. And therefore it is no wonder that things are getting overflow. We can test our hypothesis by giving it not so big numbers. So one way to do that is to limit how big this numerator and denominator can be. So one way to do that is we can use a version of next int that will create bounds for the numbers in generates. And I chose 20,000 because 20,000 times 20,000 I believe still remains within the bounds of a double. And so that should be fine or the bounds of an int and that should be fine. So if we put that in if our hunch is right then the overflow should now be taken care of. It still fails. And now we see that it's somewhat of a precision issue here with it gives us that which ends up being very close to what we wanted to be. Let's see if other errors that we face are of similar to see it's a better. And we can find out why that is. So here we are doing double precision and we are doing double precision over here. And what are we doing over here? We are doing fraction impulse but then the get value is a double is a float it should be a double. So now we should not have any precision issues because both of them are doing the same thing. So if you didn't think float versus double mattered here is a test case for why it does matter. So it's important to be consistent. In this case it was a bug in the implementation because the method clearly says I should return a double. So there is no reason why you shouldn't be doing the calculation in double precision floating point. So you can run it a few other times and convince yourself that it actually works. Alright so now what do we do about that overflow issue? So let's dig deeper. Addition of fractions by itself doesn't seem to have any direct overflow issues. If the two fractions that I give you have valid numerator and denominator then you should get a valid fraction in return. If we look at the implementation where is the overflow issue coming from? It seems to be coming from right here. Now these are all integer precision calculations. N1 and D2 are both integers so their product will also be an integer. N2 times D1 is also an integer and D1 times D2 is also an integer. They are being assigned to integers which means the overflow can occur because that operation has overflowed or that operation has overflowed or maybe they haven't but this operation has overflowed or that operation has overflowed. So all of the overflows here are related to integers and all of that is specific because this implementation decided to implement the add method in this manner. And so although there is nothing in the interface that throws an exception we must add an exception in this case for the implementation. So here's a case where an implementation actually does something extra in addition to what the interface says it must do. So this let's copy over what we have from there. And the parameter, the other fraction to be added to this one, return the resulting fraction. So if there is an arithmetic overflow in the algorithm used to compute the sum of these fractions. And now how do we detect? Well let's take that as an example. That overflows that means the product is going to be greater than integer dot max value. And that is a way we can detect overflow. We can't detect overflow by actually trying out that computation because if it has overflow and we cannot distinguish between a negative number that has resulted from it overflowing versus a positive number versus a negative number that actually is because it should be within it should be a negative number. And so we do it by saying if d2 is greater than integer dot max value divided by n1 then we throw an exception. And we do the same thing for the other two products. So that's d1 and n2 and that's d2 and d1. And finally a fourth one for the sum. So if it made it all the way here it means those products don't not overflow. And in that case it's safe to try out n1 times d2 and then check that its value is actually going to be greater than n2 times d1. So that's the other case in which this is going to overflow. Having made that change in the implementation let's now test for it. So we are going to create a very similar case here but now I'm going to remove those bounds. However now I can't put it to chance whether an overflow is going to happen or not I need an overflow to happen in this test case. So I can make it happen by not generating d2 randomly but by creating a d2 such that that product is going to overflow. So d2 is going to be integer dot max value slash n1. So this is going to be perfect and then I add a little more to it so that when I now multiply n1 times d2 the product is going to be greater than integer dot max value. So here we have veered into white box testing from black box testing and the reason is we actually know what is going to make this overflow. It is that implementation. So now we are trying to write a test with the knowledge that an implementation does something specific and so we have cracked open the box. It is our class is no longer a black box it's a white box and so this would be a white box test. So this simulates the first kind of overflow in this video I will just illustrate this one but you need to make test cases for the other kinds of overflows as well. So that product that product and finally that addition. So hopefully this will create the overflow now if it is overflow what I need to happen is that that is going to produce an exception. If it does produce an exception it works well it works correctly continue to the next trial if it does not then exception was not thrown. Let's run this test. It fails again and this time it is failing right here. And if you remember this is not even the overflow case this is the regular case. So it is failing in here because this arithmetic in the implementation assumes that n1 is not 0. Well if n1 is 0 then for this case the question of overflow of n1 times d2 does not occur at all. And so while implementing we should really say if n1 not equals 0 and all of them. And similarly over here n2 not equals 0 and that is the case and here it is going to be d1 not equal to 0 and this. So it seems sound but notice when we try to put in one fix that created another problem. If you remember these tests were all passing before we set to take care of the overflow and now that made an initial test fail. Anyway so now trying to run this test and at last it passes. So now we have successfully tested ad when it should overflow and when it should not overflow that it gives us the correct answer. So now that the ad method has been tested let's move on to the next method in the interface which is the compare to method. Now the documentation for this in the fraction class is consistent with its usage in the comparable interface. So compare this fraction with another one and return the result as an integer. And the convention for this integer is that if this fraction is less than the other then it returns a negative number. It is returns 0 if this is equal to the other and a positive number if this happens to be greater than the other. This is how the comparable interface defines it. Now the spec given to us also tells us how the comparison is actually supposed to be done. Compare as it is done using their values. So this is a little different than how we would mathematically compare two objects, two fraction objects. For example if you had two of them like this and one over D1 and N2 over D2 then the way you would compare them is you would calculate these two quantities and one times D2 and N2 times D1 and then you would compare these two numbers. That the spec says that it actually does not do this. It does it by computing the values of those fractions and comparing them. Presumably does that to avoid the overflow issues that we saw earlier with the products of two really big numbers. But whatever the case the job of our test is to check whether the given implementation follows the spec. The spec says that comparison is done by values so that is how we will test our comparative methods as well. So let us start with a simple comparison. We will create two fraction objects, two over three and three over four and then we know that two over three is less than three over four. So all we do is say check or assert on the fact that f dot compared to g is less than zero. And just to check that the comparative method is consistent what happens if instead I would call g dot compared to f. If the comparative method has been implemented correctly we have no idea how it is implemented but if it is implemented correctly this should return us a positive number. It is important to check both sides. You might think it is obvious that if f dot compared to g is less than zero then g dot compared to f must be greater than zero. But remember that this assertion depends on a certain implementation of compared to and when you are writing the test especially as a black box you cannot make any assumptions about how the comparative method has been implemented. So let us run this test and it works. So similar to the other test let us resort to random sampling so that we can check many different pairs of fractions. So we will start with the same 10,000 trials. Create a generate four random numbers that will create our two fractions. Let us read out the case once again where the denominators are zero. Comparison makes no sense if the fraction itself is invalid then we create the two fractions. And as the spec says we are going to find the difference between we are going to base the comparison on difference. So the way we test this is if f happens to be less than g then the value of f will be less than g which means the difference between their values will be negative. Similarly if f dot get value is greater than g dot get value that means the difference between them is positive and therefore we can expect that the result of the compared to method will be a positive number. So we compare the differences between their values and if the difference happens to be negative then we make sure that this returns a negative number and if we flip the two fraction objects it returns a positive number. Similarly if the difference happens to be greater than zero means f dot compare to g should be greater than zero and g dot compare to f should be less than zero. Otherwise this should be equal to zero and that should be equal to zero as well. And so we don't need these anymore. So just review our test we create two fractions and then take their difference if the difference happens to be less than zero then we check that compared to actually returns the correct number. Let's run this test to find out how it does and we find that the test fails. So it does it fails right there so it doesn't really provide us a hint about what has failed. So let me add a message here about what the difference actually is. So hopefully the actual difference will give me some sort of hint as to what might be going wrong. And so when it does fail it passes. So what does this tell you? This tells you that we may be looking at a precision issue. Now the difficulty with random sampling is what we are seeing here and earlier run of this test showed a failure. We wanted to reproduce that failure. Unfortunately when we reran this test it worked off a different sequence of random numbers. And the reason it picked a different sequence of random numbers is because this random class will pick a different seed every time which is great for the randomness of the sequence numbers. However it is a challenge when you want to reproduce the same sequence. So one easy way that we can add reproducibility to this is just make it start from the same seed again. Same seed, same sequence of random numbers and we will get a failure. Hopefully seed 100 leads to a sequence that leads to a failure and it did. And in this case we find out that the difference is actually very small. So difference is being extremely small is leading to this. So technically this is a positive number but it is so small that I think the comparative is returning is 0 instead of returning greater than 0. Now we are at kind of a loss because we do not know what precision to use. The spec simply says that the comparison is based off the differences. And so it is time for us to look at the implementation to see what it is actually doing. And indeed here you see that the absolute difference between them is treating that as a precision of up to the third decimal place. So the implementation assumes that if the values are equal to each other up to the third decimal place then these two fractions can be deemed as equal to each other. I am not sure how sound that implementation that assumption is but for now we can just replicate that in the test. Now that we know that there is an implementation specific aspect to this comparison test. And so the way we do that is we say if the difference is less than 0.001 then I just zero it out. And hopefully that will take care of the case. And that is true. Now the question is how is a user of my implementation supposed to know this? I had to look into my implementation which seems like a failure. Let us see if the documentation actually says it and we find that it actually does not. And so ideally what should have happened is because this implementation of the fraction interface adds extra information notably that if the value is close enough to three decimal places then those two fractions are deemed to be equal to each other. This information needs to be supplied in the documentation. So this is a failure of documentation of all things. So let me add that documentation now. This implementation assumes that if the values of two fractions are the same with the up to three decimal places then the two fractions are deemed to be equal to each other. Now imagine if this documentation had been part of this implementation already we wouldn't have faced this problem. We would have written this in our test from the get go. So that underscores the importance of documentation. If the spec is not complete then your test has to make an assumption that may not be consistent with the implementation that you are testing. So let us look at our compare to test again. We create two random fractions. We compute the difference between their values and then our test goes into one of these three cases. If the difference happens to be less than zero if the difference happens to be greater than zero or if the difference is exactly zero. Now the random number generator can be assumed to create a sequence of random numbers that have a uniform distribution. What that means is it is giving us a sequence of numbers that are distributed equally across the entire range of integers because I am using next int in this case. And therefore I can assume that the two fractions and thus their differences also have a uniform random distribution along the range that I am trying to take. If that is so we find that what those values are they are much more likely to be negative or positive rather than being very close to zero. The ramification of that is that although this test throws at us 10,000 different pairs of fractions the check of they being lesser than or greater than is done much, much more often than the equality case. In fact there seems no guarantee that the equals case is even tested here. And so to ensure that we are checking the equals case we will write a part of the test case explicitly for that one. So how do we check whether two fractions are equal to each other? Well we can create a constant fraction. Let us say 3 over 4 and now we can generate several new fractions that happen to be equal to that fraction. And how do we do that? We just pick a number any non zero number and we multiply the numerator and the denominator by that same number and you get a fraction that should be equal to this one. So let us apply that idea here. So I will let us say do 1000 trials generate a multiplier that is non zero. So if m is zero I will reject this trial. And now I will create a new fraction that happens to be 3 times m and 4 times m. And lastly I will assert that f dot compare to g is zero and g dot compare to f is also zero. Let us run this and it fails. So what does this tell us? It tells us that our initial suspicion is true. The part of this test case that we wrote before does not sufficiently catch the equality failures. Because before we wrote this this test was passing and now that we have written extra code to check for the equals it has detected a failure. So all was not in vain. Now what actually happened? Well the range of m can be anything. Span the whole range of integers and therefore it is possible that 3 times m or 4 times m overflows. So based on that suspicion we have to generate a value of m that we know is not going to overflow here. So if we prevent 4 times m from overflowing then 3 times m will definitely not overflow. So let us use 4 times m as our value. So if 4 times m is greater than max value then that would imply that m is greater than max value divided by 4. And so if m is greater than max value divided by 4 then we simply make m equal to max value divided by 4. On the negative side of things if 4 times m is less than min value then that would imply that m is less than min value divided by 4. So hopefully that so this should take care of the overflow we are not sure yet if that was the reason but let us check. So let us still fail. So let us print the value of m. Hopefully that will give us a clue. So let us do it for both of them. So it fails and m is this really big value. Really big negative value. Let us check. So just as a hint if I say m is math dot abs m does that take care of everything? So it seems to be a case of negative numbers. So how do I check for this? So this seems to be okay. It is this that is the problem. So 4m is less than this then I need to make 4m as equal to that. So let me make it slightly greater. Make sure I am not right at that boundary. And that is indeed what was the problem. It is the equal to min value that was resulting in some sort of an error. In any case what we just have is a case for checking the equals part of compared to which as it turns out is the next method that we should check. So let us write the test to verify that our equals method works correctly. The equals method is in some ways a subset of what we just wrote for the comparative. And so we should be able to reuse a large part of our test to do this. So the first thing we can do is check when things are equal to each other and when they should not be equal to each other. So here we have a whole bunch of things that we did. If you remember we created two random fractions. We checked their differences and we created them to zero. And so instead of there being three we can just be if there are not, if it is not equal to zero then we have to make sure that f dot equals g returns us false. And g dot equals f also returns us false. Otherwise we have to make sure that f dot equals g returns us true and g dot equals f also returns us true. So that should take care of checking whether equals returns us true when it is supposed to and false when it is not supposed to. Now testing the equals method involves more than this because you may remember that the equals method or the definition of equality must obey three conditions. One is the condition of reflexivity which tells us that a equals a. The second is the condition of symmetry a equals b implies b equals a. And finally transitivity a equals b and b equals c implies that a equals c. So this is the mathematical definition of equality and when we are overriding the equals method we are basically redefining how equality works for the objects at hand. And therefore we must ensure that our equals method has these three properties. So let us see which one of these we have tested thus far. So we have tested symmetry that is what we are doing over here. If a is equal to b then b must equal to a. We have not tested reflexivity so let us try to do that. We have to make sure that f is equal to f and g is equal to g. So this one is reflexivity this one tests symmetry. And now we need transitivity. So if a is equal to b and b is equal to c then a is equal to c. So transitivity requires that we have three fractions that are equal to each other. And so let us reuse the part here that we use to generate two fractions that we know are equal to each other. And so here we started with 3 over 4 and we have an integer m that we use to create a g and then we use we create another integer m to create a third fraction that is h. So now we have three equal fractions f, g and h. So therefore we can check for transitivity. So we can say f.compare to g is 0 and g.compare to h is 0. And this must prove that f.compare to h must be 0. So f.compare to g is 0 which means f is equal to g and g is equal to h. This must imply that f is also equal to h. So running this shows that now our equals method has the three properties of reflexivity, symmetry and transitivity. Note that we did not look at the implementation of equals at all throughout this entire test. So let us look at how it has been implemented. So having written the test for the equals method now let us proceed to write test for the last method in our implementation which is going to be the hash code. So once again reviewing why we needed hash code. Every time you override equals for a class you must override hash code and this is why. When you are overriding equals you are basically redefining what it means for two objects to be the same. When two objects are deemed to be the same then they should produce the same hash value so that a hash set or a hash map is able to find them. The way these data structures work is it converts an object to a hash value which tells it where to go store it in the table. And to determine whether something is already in the table it produces the same hash value and then it proceeds to use equals to find out whether the object that it has found in the table is indeed the same. And the table is indeed the object that you are looking for. And so if your equals has been overridden you have to make sure that your hash code is now consistent. What does that mean? It means that if two objects are deemed to be equal to each other then they better produce the same hash code. It is important to note that the the the converse is not true meaning if two objects are different then ideally they should produce different hash codes but it is not necessary. So what we need to test hash is two fraction objects that are equal to each other and we have already spent quite a lot of time generating such fractions. And so let me basically borrow from a previous test case. So we will start with two fraction objects we will generate a 3 over 4 and we need our random number generator. And we will generate another fraction 3 over 4 that is going to be our or multiple of 3 over 4 that's going to be our fraction that's equal to them. And then because f and g are equal to each other all we need to check is that f dot hash code is the same thing as g dot hash code. And so for a particular fraction we generate a lot of equal fraction to it and we basically say are they the same hash codes. And the test passes now if you wish you can also generate this fraction randomly instead of being 3 over 4 what you would need to then check is you take two random numbers make them the numerator and denominator of f and then you choose the bigger of the random numbers and you replace the 4 here with that bigger one. And this test case should work. So let's take stock of all the tests that we have written we wrote one that checks whether a fraction is created when all the proper inputs are given to it. We have a test case that test if the fraction constructor works correctly or works expected meaning it throws an exception when the denominator passed to it is 0. We also wrote a test that tested all the getters get numerator get denominator is negative and get value. Then we wrote a test to see if two fractions are added properly so we added we created two random fractions we create we found their expected value and then we compared it to the expected value. This also unearthed some overflow issues which were specific to the implementation of fractions and therefore we created tests that make sure that when overflow occurs it does throw an arithmetic exception but when overflow does not occur it does not throw an exception. Then we wrote a case for compare and in order to get more samples for the equality case we wrote several more cases for the equality that is the case where f dot compare to g returns a 0 those became also the tests for our equals method. In addition to those tests we checked for the three properties reflexivity symmetry symmetry and transitivity and finally because we over wrote equals we had to override hash code and we wrote a test to ensure that when we have two fraction objects that are equal to each other they generate the same hash code. For a relatively simple class such as fraction you could see in this video that there were many cases we dealt with overflow we dealt with precision issues and so on and so forth and we ended up with a set of tests. We also saw repeatedly the use of random numbers to create basically a large set of sample inputs quickly that could help us test our class with a large number of inputs without going through comprehensively every possible input. Now as you know you can run all these test cases in one fell swoop by just running all the tests in this class and that will show you that we have run we have created seven tests and all of them run successfully. This brings an end to this video hopefully this illustrates the testing process for you and will help you in writing your own well defined tests for the classes that you are trying to test. It had a combination of white box and black box testing and we tried to write as many tests as we could before we started to or before we even looked at the implementation so that we wrote unbiased tests. Thank you.